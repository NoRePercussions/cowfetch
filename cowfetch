#!/usr/bin/env bash

# COLOR VARIABLES
RED="\x1b[31m"
YELLOW="\x1b[33m"
GREEN="\x1b[32m"
CYAN="\x1b[36m"
BLUE="\x1b[34m"
PURPLE="\x1b[35m"
BLACK="\x1b[30m"
WHITE="\x1b[37m"
B_RED="\x1b[91m"
B_YELLOW="\x1b[93m"
B_GREEN="\x1b[92m"
B_CYAN="\x1b[96m"
B_BLUE="\x1b[94m"
B_PURPLE="\x1b[95m"
B_WHITE="\x1b[97m"
GRAY="\x1b[90m"
CLS="\x1b[0m"

# Cool characters for the symbol ◆ ◀ ▧ ▨ ▦ ▥ ▤ ▣ ● ◕ █
SYMBOL="●"
SEPARATOR="-"
# Set colors
TXTCOL=$YELLOW
WORDCOL=$GREEN
BUBBLECOL=$WHITE
COWCOL=$CYAN

# WM script by Alberto Salvia Novella (es20490446e.wordpress.com)
CPU=$(grep -m 1 'model name' /proc/cpuinfo)
RAM=$(free -h | grep "^Mem:" | awk '{print $3 "/" $2}')
OS=$(grep -m1 "NAME=" < /etc/os-release | cut -d '"' -f 2)
WM=${WAYLAND_DISPLAY:-$(xprop -id "$(xprop -root _NET_SUPPORTING_WM_CHECK | cut -d' ' -f5)" _NET_WM_NAME | cut -d'"' -f2)} # Thanks to kazoku
ARCH=$(uname -m)
NODE=$(uname -n)
NAME=${LOGNAME}@${NODE}
KERNEL_NAME=$(uname -s)
KERNEL_REL=$(uname -r)
KERNEL="${KERNEL_NAME} ${KERNEL_REL}"
SHELL_NAME=$(cat /proc/$$/comm) # How does this even work
UPTIME=$(uptime -p) # ??
RESOLUTION=$(xrandr | grep "*" | awk '{print $1}') # ???
USED_SPACE=$(df -h / | awk '{print $3}' | grep "^[0-9]")
TOTAL_SPACE=$(df -h / | awk '{print $2}' | grep "^[0-9]")
SPACE="$USED_SPACE/$TOTAL_SPACE"
GPU=$(glxinfo | grep "Device")
TERMINAL=$(TERM_PID=$(ps -p $$ -o args,ppid | grep -o "[0-9]" | tr -d "\n"); ps -p ${TERM_PID} -o args | tr -d "\n")

Help()
{
        printf "
-m      Adds more info, like the system architecture and graphic session(X11 or WAYLAND) to the output
-d      Adds your dark color palette to the output
-b      Adds your bright color palette to the output
-c	Adds both your dark and bright color palette to the output
-a	Adds all of the options above
-h      Shows this help message\n
This program is licensed under the GPLv3 license.\n
If you encounter any issue or want a feature to be added please open an issue on the GitHub page.
https://github.com/bradeythedev/cowfetch \n
"
}

ExtraInfo()
{
FEDORA="Fedora Linux"
case ${OS,,} in
    arch)
	ARCH_PKG=$(pacman -Qq --color never > packnum.txt && wc -l packnum.txt)
	echo -e "                ${WORDCOL}Packages: ${TXTCOL}${ARCH_PKG} (pacman)"
    ;;
    debian)
	DEB_PKG=$(dpkg-query -f '${binary:Package}\n' -W | wc -l)
	echo -e "                ${WORDCOL}Packages: ${TXTCOL}${DEB_PKG} (dpkg)"
    ;;
    ubuntu)
	DEB_PKG=$(dpkg-query -f '${binary:Package}\n' -W | wc -l)
	echo -e "                ${WORDCOL}Packages: ${TXTCOL}${DEB_PKG} (dpkg)"
    ;;
    void)
    	XBPS_PKG=$(xbps-query -l | wc -l)
	echo -e "                ${WORDCOL}Packages: ${TXTCOL}${XBPS_PKG} (xbps)"
    ;;
    "fedora linux")
    	RPM_PKG=$(rpm -qa | wc -l)
	echo -e "                ${WORDCOL}Packages: ${TXTCOL}${RPM_PKG} (rpm)"
    ;;
esac

}

DarkColor()
{
	echo -e "                ${RED} ${SYMBOL} ${YELLOW} ${SYMBOL} ${GREEN} ${SYMBOL} ${CYAN} ${SYMBOL} ${BLUE} ${SYMBOL} ${PURPLE} ${SYMBOL} ${WHITE} ${SYMBOL} ${BLACK} ${SYMBOL} ${CLS}"
}

BrightColor()
{
	echo -e "                ${B_RED} ${SYMBOL} ${B_YELLOW} ${SYMBOL} ${B_GREEN} ${SYMBOL} ${B_CYAN} ${SYMBOL} ${B_BLUE} ${SYMBOL} ${B_PURPLE} ${SYMBOL} ${B_WHITE} ${SYMBOL} ${GRAY} ${SYMBOL} ${CLS}"
}

Color()
{
        echo -e "                ${RED} ${SYMBOL} ${YELLOW} ${SYMBOL} ${GREEN} ${SYMBOL} ${CYAN} ${SYMBOL} ${BLUE} ${SYMBOL} ${PURPLE} ${SYMBOL} ${WHITE} ${SYMBOL} ${BLACK} ${SYMBOL} ${CLS}"
	echo -e "                ${B_RED} ${SYMBOL} ${B_YELLOW} ${SYMBOL} ${B_GREEN} ${SYMBOL} ${B_CYAN} ${SYMBOL} ${B_BLUE} ${SYMBOL} ${B_PURPLE} ${SYMBOL} ${B_WHITE} ${SYMBOL} ${GRAY} ${SYMBOL} ${CLS}"
}

# Get length of longest line
FindBubbleWidth()
{
	BUBBLEWIDTH=0

	# Find the lengths of all the lines - this excludes the bubble and the prefix (eg. [WM:  ], [CPU: ]), because this isn't required to find the longest line or print the right side of the bubble
	NAME_LENGTH=${#NAME}
	OS_LENGTH=${#OS}
	KN_LENGTH=${#KERNEL}
	AR_LENGTH=${#ARCH}
	WM_LENGTH=${#WM}
	GS_LENGTH=${#XDG_SESSION_TYPE}
	SH_LENGTH=${#SHELL_NAME}
	UP_LENGTH=${#UPTIME}
	UP_LENGTH=$(($UP_LENGTH-3))

	CPU_LENGTH=${#CPU}
	CPU_LENGTH=$(($CPU_LENGTH-13))
	GPU_LENGTH=${#GPU}
	RAM_LENGTH=${#RAM}
	RES_LENGTH=${#RESOLUTION}
	USE_LENGTH=${#SPACE}

	# Print the line lengths for debugging
	echo $NAME_LENGTH
	echo $OS_LENGTH
	echo $KN_LENGTH
	echo $AR_LENGTH
	echo $WM_LENGTH
	echo $GS_LENGTH
	echo $SH_LENGTH
	echo $UP_LENGTH

	echo $CPU_LENGTH
	echo $GPU_LENGTH
	echo $RAM_LENGTH
	echo $RES_LENGTH
	echo $USE_LENGTH

	# Compare the line lengths - if the current longest line is shorter than the next, the longest is set to that, so by the end the longest line has been found
	# It is not recorded as what line is the longest, but as that line's length.
	if (( NAME_LENGTH > BUBBLEWIDTH ))
	then BUBBLEWIDTH=$NAME_LENGTH
	fi
	
	if (( OS_LENGTH > BUBBLEWIDTH ))
	then BUBBLEWIDTH=$OS_LENGTH
	fi

	if (( KN_LENGTH > BUBBLEWIDTH ))
	then BUBBLEWIDTH=$KN_LENGTH
	fi

	if (( AR_LENGTH > BUBBLEWIDTH ))
	then BUBBLEWIDTH=$AR_LENGTH
	fi

	if (( WM_LENGTH > BUBBLEWIDTH ))
	then BUBBLEWIDTH=$WM_LENGTH
	fi

	if (( GS_LENGTH > BUBBLEWIDTH ))
	then BUBBLEWIDTH=$GS_LENGTH
	fi

	if (( SH_LENGTH > BUBBLEWIDTH ))
	then BUBBLEWIDTH=$SH_LENGTH
	fi

	if (( UP_LENGTH > BUBBLEWIDTH ))
	then BUBBLEWIDTH=$UP_LENGTH
	fi

	if (( CPU_LENGTH > BUBBLEWIDTH ))
	then BUBBLEWIDTH=$CPU_LENGTH
	fi

	if (( GPU_LENGTH > BUBBLEWIDTH ))
	then BUBBLEWIDTH=$GPU_LENGTH
	fi

	if (( RAM_LENGTH > BUBBLEWIDTH ))
	then BUBBLEWIDTH=$RAM_LENGTH
	fi

	if (( RES_LENGTH > BUBBLEWIDTH ))
	then BUBBLEWIDTH=$RES_LENGTH
	fi

	if (( USE_LENGTH > BUBBLEWIDTH ))
	then BUBBLEWIDTH=$USE_LENGTH
	fi

	# Print the longest line's length, for debugging
	echo $BUBBLEWIDTH
}

# Dashed separator
Separator()
{
	RIGHT_LENGTH=$((BUBBLEWIDTH-NAME_LENGTH))
	printf "${BUBBLECOL} | "
	for (( i=0; i<NAME_LENGTH; i++ )); do printf "-"; done
	SpaceUntilRightSide
	#printf "\e[0m\n" # newline- i think
}

Underscores()
{
	for (( i=0; i<BUBBLEWIDTH; i++ )); do printf "_"; done
}

SpacesUnderUnderscores()
{
	for (( i=0; i<BUBBLEWIDTH; i++ )); do printf " "; done
}

SpaceUntilRightSide()
{
	for (( i=0; i<RIGHT_LENGTH; i++ )); do printf " "; done
	printf "${BUBBLECOL} |"
	echo -e ""
}

FindBubbleWidth

BUBBLEWIDTH=$(($BUBBLEWIDTH+5))

# Top of bubble
printf "${BUBBLECOL}   "
Underscores
echo -e ""
printf "${BUBBLECOL}  /"
SpacesUnderUnderscores
echo -e "\\"
printf "${BUBBLECOL} | ${COWCOL}$LOGNAME@$NODE"
RIGHT_LENGTH=$(( BUBBLEWIDTH-NAME_LENGTH ))
SpaceUntilRightSide

# First separator
Separator

BUBBLEWIDTH=$(($BUBBLEWIDTH-5))

# Software info
printf "${BUBBLECOL} | ${WORDCOL}OS:  ${TXTCOL}${OS}"
RIGHT_LENGTH=$(( BUBBLEWIDTH-OS_LENGTH ))
SpaceUntilRightSide
printf "${BUBBLECOL} | ${WORDCOL}KN:  ${TXTCOL}${KERNEL}"
RIGHT_LENGTH=$(( BUBBLEWIDTH-KN_LENGTH ))
SpaceUntilRightSide
printf "${BUBBLECOL} | ${WORDCOL}AR:  ${TXTCOL}${ARCH}"
RIGHT_LENGTH=$(( BUBBLEWIDTH-AR_LENGTH ))
SpaceUntilRightSide
printf "${BUBBLECOL} | ${WORDCOL}WM:  ${TXTCOL}${WM}"
RIGHT_LENGTH=$(( BUBBLEWIDTH-WM_LENGTH ))
SpaceUntilRightSide
printf "${BUBBLECOL} | ${WORDCOL}GS:  ${TXTCOL}$XDG_SESSION_TYPE"
RIGHT_LENGTH=$(( BUBBLEWIDTH-GS_LENGTH ))
SpaceUntilRightSide
printf "${BUBBLECOL} | ${WORDCOL}SH:  ${TXTCOL}${SHELL_NAME}"
RIGHT_LENGTH=$(( BUBBLEWIDTH-SH_LENGTH ))
SpaceUntilRightSide
printf "${BUBBLECOL} | ${WORDCOL}UP:  ${TXTCOL}${UPTIME:3}"
RIGHT_LENGTH=$(( BUBBLEWIDTH-UP_LENGTH ))
SpaceUntilRightSide

BUBBLEWIDTH=$(($BUBBLEWIDTH+5))

# Second separator
Separator

BUBBLEWIDTH=$(($BUBBLEWIDTH-5))

# Hardware info
printf "${BUBBLECOL} | ${WORDCOL}CPU: ${TXTCOL}${CPU:13}"
RIGHT_LENGTH=$(( BUBBLEWIDTH-CPU_LENGTH ))
SpaceUntilRightSide
printf "${BUBBLECOL} | ${WORDCOL}GPU: ${TXTCOL}${GPU:12}"
RIGHT_LENGTH=$(( BUBBLEWIDTH-GPU_LENGTH ))
SpaceUntilRightSide
printf "${BUBBLECOL} | ${WORDCOL}RAM: ${TXTCOL}${RAM}"
RIGHT_LENGTH=$(( BUBBLEWIDTH-RAM_LENGTH ))
SpaceUntilRightSide
printf "${BUBBLECOL} | ${WORDCOL}RES: ${TXTCOL}${RESOLUTION}"
RIGHT_LENGTH=$(( BUBBLEWIDTH-RES_LENGTH ))
SpaceUntilRightSide
printf "${BUBBLECOL} | ${WORDCOL}USE: ${TXTCOL}${USED_SPACE}/${TOTAL_SPACE}"
RIGHT_LENGTH=$(( BUBBLEWIDTH-USE_LENGTH ))
SpaceUntilRightSide

BUBBLEWIDTH=$(($BUBBLEWIDTH+5))

# Bottom of bubble
printf "${BUBBLECOL}  \\"
Underscores
echo -e "/"

# moo
echo -e "${BUBBLECOL}       \\"
echo -e "${BUBBLECOL}        \\ ${COWCOL}  ^__^"
echo -e "${BUBBLECOL}         \\ ${COWCOL} (oo)\\_______"
echo -e "${COWCOL}            (__)\\       )\\/\\"
echo -e "${COWCOL}                ||----w |"
echo -e "${COWCOL}                ||     ||"

# End
printf "\e[0m\n"

while getopts ":hmabdc" option; do
   case $option in
      h) #	Get help message
	 printf "${CLS}"
	 Help
	 exit;;
      m) #	Get more info
	 ExtraInfo
	 printf "${CLS}";;
      a) # 	Get all of the info
         ExtraInfo
	 DarkColor
	 BrightColor
	 printf "${CLS}";;
      b) #      Display bright color palette
         Separator
         BrightColor
	 printf "${CLS}";;
      d) #	Display dark color palette
         Separator
	 DarkColor
	 printf "${CLS}";;
      c) #	Display both bright and dark color palette
      	 Separator
	 DarkColor
	 BrightColor
	 printf "${CLS}";;
      ?) #     Get unknown command output
	 printf "${CLS}\n"
         echo "This option does not exist. For the full list of options please use the command 'cowfetch -h'"
         exit;;
   esac
done


# /'._   ._
#(- = 7___.~'
# |--''   )
# LL_)'CC_J
